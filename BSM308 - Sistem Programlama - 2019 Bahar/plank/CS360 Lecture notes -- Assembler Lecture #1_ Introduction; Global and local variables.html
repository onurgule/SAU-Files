
<!-- saved from url=(0085)http://web.eecs.utk.edu/~jplank/plank/classes/cs360/360/notes/Assembler1/lecture.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>CS360 Lecture notes -- Assembler Lecture #1: Introduction; Global and local variables</title>
</head><body bgcolor="ffffff">
<h2>CS360 Lecture notes -- Assembler Lecture #1: Introduction; Global and local variables</h2>
<ul>
<li><a href="http://web.eecs.utk.edu/~jplank">James S. Plank</a>
</li><li>Directory: <b>/home/plank/cs360/notes/Assembler1</b>
</li><li>Lecture notes:
    <a href="http://web.eecs.utk.edu/~jplank/plank/classes/cs360/360/notes/Assembler1/lecture.html">
    <b>
  http://web.eecs.utk.edu/~jplank/plank/classes/cs360/360/notes/Assembler1/lecture.html
</b></a>
</li><li> Original notes: Sometime in the 1990's
</li><li> Latest modification: 
Wed Feb 14 15:26:21 EST 2018
</li></ul>
<hr>

This is the beginning lecture on computer organization &amp; stack frames.  
<p>
My goal is to teach you how assembly code is generated by a compiler to work
on a standard processor.  I don't do this in a precise manner, as would be 
done in a compiler course, but in a manner that is intended to be more intuitive.
</p><p>
The assembly code is a made-up RISC assembly code
that works on a fictitious machine that has 4-byte pointers and no floating point.  
I have written a visual assembler for it so that you can see it in action.

</p><hr>
<h1>Registers</h1>

We're going to assume a general computer architecture, which differs 
slightly from most machines, but is exemplary of almost all uniprocessors.<p>

We'll assume that our machine has 8 general-purpose registers in the CPU.
All are 4 bytes, and can be read or written by the user.  The first five
are named <b>r0</b>, <b>r1</b>, 
<b>r2</b>, <b>r3</b>, <b>r4</b>.
The last three registers are special:</p><p>

</p><ul>
<li> The sixth is named <b>sp</b> and is called the "<i>stack pointer</i>."  
</li><li> The seventh is named <b>fp</b> and is called the "<i>frame pointer</i>."  
</li><li> The eighth is named <b>pc</b> and is called the "<i>program counter</i>."  
</li></ul>

<p>
Additionally, the computer has three read-only registers, which always 
contain the same values:

</p><ul>
<li> <b>g0</b>, whose value is always zero.
</li><li> <b>g1</b>, whose value is always one.
</li><li> <b>gm1</b>, whose value is always negative one.
</li></ul>

<p>
Finally, the computer also has two special registers that the user cannot 
access directly:</p><p>

</p><ul>
<li><b>IR</b> -- The instruction register.  
        It holds the instruction currently being executed.
</li><li><b>CSR</b> -- The control status register.  
        It contains information pertaining to
         the execution of the current and previous instructions.
</li></ul>

<hr>
<h1>The instruction cycle</h1>

The computer's operation consists of running instructions repetitively. 
This is known as the instruction cycle.  The instruction cycle consists
of 4 general phases:

<ul>
<li>	1. Decode instruction (in <b>IR</b>)
</li><li>	2. Execute instruction
</li><li>	3. Determine next instruction, and update the <b>pc</b> accordingly
</li><li>	4. Load next instruction into the <b>IR</b>
</li></ul>

What is an instruction?  Like everything else, it's a sequence of
0's and 1's.   We're going to assume that all of our instructions
are 32 bits (although that's a naive assumption, it will work for
our purposes).  Instructions are stored as part of a program's
memory, and the instruction that is pointed to by  the <b>pc</b> 
register is the
one that gets loaded into the <b>IR</b> for execution.<p>
In other words, if the <b>pc</b> contains the value <b>0x2040</b>, 
then the <b>IR</b> is executing the instruction contained in the
4 bytes starting at memory address <b>0x2040</b>.
</p><p>

<i>Assembly code</i> is a readable encoding of instructions.
A program called an <i>assembler</i> converts assembly code
into the proper 0's and 1's that compose the program.  If you 
call <b>gcc</b> with the <b>-S</b> flag, it will produce a <b>.s</b>
file containing the assembler for that C program.  Without
the <b>-S</b> flag, it produces the instructions directly.</p><p>

</p><h2>Instructions</h2>

<h3>1. Memory &lt;-&gt; Register instructions:</h3>

<pre>       ld mem -&gt; %reg        Load the value of the register from memory.

       st %reg -&gt; mem        Store the value of the register into memory.
</pre>
There are a few ways to address memory:
<pre>       st %r0 -&gt; i         Store the value of register r0 into the memory 
                           location of global variable i.

       st %r0 -&gt; [r1]      Treat the value of register r1 as a pointer
                           to a memory location, and store the
                           value of r0 in that memory location.

       st %r0 -&gt; [fp+4]    Treat the value of the frame pointer as a
                           pointer to a memory location, and store
                           the value of r0 in the memory location 4
                           bytes after that location.  You can use
                           any value, positive or negative -- the
                           value must be a multiple of four.
                           However, you cannot use a register (i.e.
                           you can't do st %r0 -&gt; [fp+r2]).  This
                           only works with the frame pointer.  It
                           does not work with any other register.
                           
       st %r0 -&gt; [sp]--    Treat the value of register sp as a
                           pointer to a memory location, store the
                           value of r0 into that memory location, and then
                           subtract 4 to the value of sp.

       st %r0 -&gt; ++[sp]    Treat the value of register sp as a
                           pointer to a memory location. First, add 4 to
                           that value, then store the
                           value of r0 into that memory location.
</pre>

<h3>    2. Register &lt;-&gt; Register instructions:</h3>
      
<pre>       mov %reg -&gt; %reg    Copy a register's value to another
       mov #val -&gt; %reg    register, or set its value to a constant.
</pre>
       All arithmetic goes from register to register:
<pre>       add %reg1, %reg2 -&gt; %reg3   Add reg1 &amp; reg2 and put the sum in reg3.
       sub %reg1, %reg2 -&gt; %reg3   Subtract reg2 from reg1.
       mul %reg1, %reg2 -&gt; %reg3   Multiply reg1 &amp; reg2.
       idiv %reg1, %reg2 -&gt; %reg3  Do integer division of reg2 into reg1.
       imod %reg1, %reg2 -&gt; %reg3  Do reg1 mod reg2.
</pre>
       There are two special instructions that let you perform addition
       and subtraction on the stack pointer:
<pre>       push %reg           This subtracts the value of %reg or #val 
       push #val           from the stack pointer.

       pop %reg            This adds the value of %reg or #val 
       pop #val            to the stack pointer.
</pre>


<h3>    3. Control instructions</h3>

<pre>       jsr a	           Call the subroutine starting at instruction a.
       ret		   Return from a subroutine.
</pre>
There are also "compare" and "branch" instructions, which is how you implement
        for and if statements, but I won't go over them yet.
<p>
Finally, there are also "directives" which are not really code, but specify
that memory must be allocated for variables.  In this assembler, this is just one such
directive:

</p><pre>       .globl i           Allocate 4 bytes in the globals segment
                          for the variable i.
</pre>

<p>
The program counter points to where the instruction register must go to 
load its value.  On normal instructions, the <b>pc</b> is incremented by 4 
so that the next instruction can be loaded.  On control instructions, 
the <b>pc</b> gets a new value, allowing the machine to call 
subroutines, perform "if-then" statements, etc.
       
</p><hr>
<h1>The address space</h1>

   Each program's view of its memory is called an "<i>address
   space</i>".  Typically an address space is broken up into 4 parts:
   The <i>code</i>, <i>globals</i>, <i>heap</i>, and <i>stack</i>.  The
   code holds nothing but instructions.  The globals is where global
   variables are stored, and the heap is where malloc'd storage
   lives.  The stack is for temporary storage, like local variables
   and arguments for procedures.<p>

   Generally, a process treats memory like a huge array of bytes;
   however, the bytes are organized logically into units of 4 bytes
   each, as that is the size of registers.  We assume that this
   memory is of size 0x80000000.  The code
   starts at address 0x1000.  The globals follow the code, starting in the
   first address that is a multiple of 4096 (0x1000).  On a real machine,
   the heap would follow the code, or start at some other address which 
   is a multiple of 4096.  With <b>jassem</b>, there is no heap.</p><p>

   As a program executes, the stack will 
   grow and shrink, but the code and globals stay the
   same size.  The stack grows from back to front, starting at
   address 0x80000000 and growing toward lower memory addresses.
   In between the globals and stack is unused memory:

</p><pre>         The programs' address space:
         |--------------------------|&lt;------- 0x00000000
         |  No access (Seg faults)  |
         |--------------------------|&lt;------- 0x00001000
         |                          |
         |          code            |
         |                          |
         |--------------------------|
         |                          |
         |         globals          |
         |                          |
         |--------------------------|
                   ....               
                Unused memory
                   ....               
         |                          |
         |      (grows up)          |
         |^^^^^^^^^^^^^^^^^^^^^^^^^^|
         |                          |
         |         stack            |
         |                          |
         |--------------------------|&lt;------- 0x80000000
</pre>


<hr>
<h1>Simple compiled code.</h1>

The C compiler takes C code, and translates it into instructions.  
What we're doing in this and the following lectures is seeing how this
translation works.  The assembler code produced by the translation
consists of machine instructions and 
directives.  The translation is very logical.
For example, the following code:<p>

</p><p></p><center><table border="3" cellpadding="3"><tbody><tr><td><pre>int i;
int j;

int main()
{
  i = 1;
  j = 2;
  j = i + j;
}            <font color="blue">/* I am intentionally not returning anything. */</font>
</pre></td></tr></tbody></table></center><p>

Will compile into the following assembly code:

</p><p></p><center><table border="3" cellpadding="3"><tbody><tr><td><pre>    .globl i                      <font color="blue">/ Allocate i and j as global variables.</font>
    .globl j
main:
    mov #1 -&gt; %r0              <font color="blue">/ i = 1</font>
    st  %r0 -&gt; i
    mov #2  -&gt; %r0             <font color="blue">/ j = 2</font>
    st  %r0 -&gt; j
    ld  i   -&gt; %r0             <font color="blue">/ j = i + j</font>
    ld  j   -&gt; %r1
    add %r0,%r1  -&gt; %r1
    st  %r1 -&gt; j
    ret
</pre></td></tr></tbody></table></center><p>

This code is pretty straightforward.  Each instruction in C has a 
corresponding set of instructions in assembler.  Unless your compiler 
is smart, it will produce inefficient code.  For example, you can 
probably see that:

</p><pre>	.globl i
	.globl j
    main:
	mov #1  -&gt; %r0
	mov #2  -&gt; %r1
	add %r0,%r1  -&gt; %r1
        st  %r1 -&gt; j
	st  %r0 -&gt; i
        ret
</pre>

would work just as well, and has fewer instructions.  If you call <b>gcc</b>
with the <b>-O</b> flag, it will attempt to optimize your code so that it
has fewer instrcutions.  However, normally, <b>gcc</b> simply produces 
straightforward, unoptimized code.  In this class (I'll repeat this over
and over), we are going to produce unoptimized code, which means that every
C statement is translated to assembly code independently.  No assumptions
are made from one statement to the next.  We leave compiler optimization to
another course (like a compiler course)
<p>

Now, suppose instead that we have the following code to run:

</p><p></p><center><table border="3" cellpadding="3"><tbody><tr><td><pre>int main()
{
  int i, j;

  i = 1;
  j = 2;
  j = i + j;
}
</pre></td></tr></tbody></table></center><p>
  
Since <b>i</b> and <b>j</b> are local variables, they must come from
temporary storage: The stack.  How does the stack work?  It is
governed by the <b>sp</b> and <b>fp</b> registers.  The <b>sp</b> and
<b>fp</b> designate what is known as a "<i>frame</i>" on the stack.
The <b>fp</b> points to the bottom of the frame, and the <b>sp</b>
points to the top.  All memory locations above (less than or equal
to) the stack pointer are considered unused.  Thus, we can get new temporary memory
by decrementing the <b>sp</b>, thus putting memory locations into the
current stack frame.</p><p> 

For example, When a procedure is first called, these two registers
point to the same place in the stack.  The frame is considered empty.

</p><pre>           ....
    |----------------|
    |     unused     | 
    |----------------|
    |     unused     |  &lt;------------- sp, fp
    |----------------|
    |      used      | 
    |----------------|
    |      used      | 
    |----------------|
           ....
    |----------------|
    |      used      | 
    |----------------|
			    &lt;---------- Location 0x80000000
</pre>


To allocate room for the two local variables <b>i</b> and <b>j</b>, 
we decrement 
the stack pointer by 8.  This allocates two 4-byte quantities in the 
current stack frame:  By convention, we'll call the lower one <b>j</b>, and 
the upper one <b>i</b>.  This is something that the compiler defines.  We could
just as easily have called the lower one <b>i</b>, and the upper one <b>j</b>:

<pre>           ....
    |----------------|
    |     unused     |  &lt;------------- sp
    |----------------|
    |       i        | 
    |----------------|
    |       j        |  &lt;------------- fp
    |----------------|
    |      used      | 
    |----------------|
    |      used      | 
    |----------------|
           ....
    |----------------|
    |      used      | 
    |----------------|
			    &lt;---------- Location 0x80000000
</pre>


Now, the code for <b>main()</b> is just like before, only instead of accessing
<b>i</b> and <b>j</b> as global variables, we access them as offsets to the frame
pointer.

<p></p><center><table border="3" cellpadding="3"><tbody><tr><td><pre>main:
        push #8                  <font color="blue">/ This allocates i and j</font>
        mov #1   -&gt; %r0
        st  %r0 -&gt; [fp-4]        <font color="blue">/ Set i to 1</font>
        mov #2  -&gt; %r0
        st  %r0 -&gt; [fp]          <font color="blue">/ Set j to 2</font>
        ld  [fp-4]  -&gt; %r0
        ld  [fp]    -&gt; %r1
        add %r0,%r1 -&gt; %r1       <font color="blue">/ Add i and j and put the result</font>
        st  %r1 -&gt; [fp]          <font color="blue">/ back into j</font>
        ret
</pre></td></tr></tbody></table></center><p>

Let's look at what happens when <b>main()</b> is executed:

</p><pre>          Stack                  
    |----------------|            
    |                |                          registers            
    |                |                     |-----------------|
    |                |                     |                 | r0
    |                |                     |                 | r1
    |    .....       |                     |                 | r2
    |    unused      |                     |                 | r3
    |    unused      |                     |                 | r4
    |    unused      |        /----------- |                 | sp
    |    unused      | &lt;------------------ |                 | fp
    |     used       |                     |    main         | pc
    |     ....       |                     |-----------------| 
    |--------------- |                    
</pre>
                                         
Note that the <b>fp</b> and <b>sp</b> point to the base of the 
empty stack frame.
The <b>pc</b> points to the beginning of the main routine.  This is the
instruction "<b>push #8</b>".  When this is done executing, we
have the following:

<pre>          Stack                              registers
    |----------------|                     |-----------------|
    |                |                     |                 | r0
    |                |                     |                 | r1
    |    .....       |                     |                 | r2
    |    unused      |                     |                 | r3
    |    unused      | &lt;---------------\   |                 | r4
    |       i        |                  \- |                 | sp
    |       j        | &lt;------------------ |                 | fp
    |     used       |                     |    main + 4     | pc
    |     ....       |                     |-----------------| 
    |--------------- |                    
</pre>

Space has been allocated on the current stack frame for <b>i</b> and <b>j</b>, 
and the <b>pc</b> has been incremented.  It now points to the instruction
"<b>mov 1   -&gt; %r0</b>"  This puts the machine into the following state:

<pre>          Stack                              registers
    |----------------|                     |-----------------|
    |                |                     |       1         | r0
    |                |                     |                 | r1
    |    .....       |                     |                 | r2
    |    unused      |                     |                 | r3
    |    unused      | &lt;---------------\   |                 | r4 
    |       i        |                  \- |                 | sp
    |       j        | &lt;------------------ |                 | fp
    |     used       |                     |    main + 8     | pc
    |     ....       |                     |-----------------|
    |--------------- |
</pre>

Now, the <b>pc</b> points to "<b>st  %r0 -&gt; [fp-4]</b>".  
When this is done, the location 
for <b>i</b> is set to the value 1:

<pre>          Stack                              registers
    |----------------|                     |-----------------|
    |                |                     |       1         | r0
    |                |                     |                 | r1
    |    .....       |                     |                 | r2
    |    unused      |                     |                 | r3
    |    unused      | &lt;---------------\   |                 | r4
    |       i=1      |                  \- |                 | sp
    |       j        | &lt;------------------ |                 | fp
    |     used       |                     |    main + 12    | pc
    |     ....       |                     |-----------------|
    |--------------- |
</pre>


After the next two instructions, the state of the machine will be:

<pre>            mov #2   -&gt; %r0
            st  %r0 -&gt; [fp]        

          Stack                              registers
    |----------------|                     |-----------------|
    |                |                     |       2         | r0
    |                |                     |                 | r1
    |    .....       |                     |                 | r2
    |    unused      |                     |                 | r3
    |    unused      | &lt;---------------\   |                 | r4
    |       i=1      |                  \- |                 | sp
    |       j=2      | &lt;------------------ |                 | fp
    |     used       |                     |    main + 20    | pc
    |     ....       |                     |-----------------|
    |--------------- |
</pre>

Finally, the last 4 instructions do:

<pre>            ld  [fp-4]  -&gt; %r0
            ld  [fp]    -&gt; %r1
            add %r0,%r1 -&gt; %r1    
            st  %r1     -&gt; [fp]      

          Stack                              registers
    |----------------|                     |-----------------|
    |                |                     |       1         | r0
    |                |                     |       3         | r1
    |    .....       |                     |                 | r2
    |    unused      |                     |                 | r3
    |    unused      | &lt;---------------\   |                 | r4
    |       i=1      |                  \- |                 | sp
    |       j=3      | &lt;------------------ |                 | fp
    |     used       |                     |    main + 36    | pc
    |     ....       |                     |-----------------|
    |--------------- |
</pre>

<hr>
<h1>Jassem -- The Visual Assembler</h1>

To help you understand assembler, I have written a simple visual assembler
that lets you load assembly code programs and step through them.  It has
been written in the graphical scripting language <b>tcl/tk</b>.
<p>
You can get this file from this directory, in <b>jassem.tcl</b>.
</p><p>
The nice thing about tcl/tk is that it works on Unix, Windows, and Macintosh.
To use <b>jassem.tcl</b> on our machines, simply run :
</p><pre><b>UNIX&gt;</b> wish ~jplank/cs360/bin/jassem.tcl [filename]
</pre>
<b>Wish</b> should be installed on all of our machines.
<p>
To use <b>jassem.tcl</b> on a Windows or Macintosh machine, you will
need to install tcl/tk.  This is free -- get the code from
<b>www.scriptics.com</b>.  
</p><p>
In running <b>jassem.tcl</b>, the first thing you do is load a program, such
as <a href="http://web.eecs.utk.edu/~jplank/plank/classes/cs360/360/notes/Assembler1/p1-g.jas"><b>p1-g.jas</b></a> (the program above that adds global
variables) or
<a href="http://web.eecs.utk.edu/~jplank/plank/classes/cs360/360/notes/Assembler1/p1.jas"><b>p1.jas</b></a> (the program above that adds local 
variables).  You should 
see a picture of the system -- stack, registers, globals and code,
as below:
</p><p>
</p><center>
<img src="./CS360 Lecture notes -- Assembler Lecture #1_ Introduction; Global and local variables_files/jassem-ss.gif">
</center>
<p>
Now you can step through the program, looking at everything as you
go.  Make sure you understand each step as you go through it.
This is a very helpful tool.
</p><p>
In <b>jassem</b>, the code starts at 0x1000, and global variables, if they exist, start
at the next multiple of 0x1000.  There is no heap.  The stack ends at 0xfff44c.  That's
pretty arbitrary, but such is life.

</p><hr>
<h1>Addendum</h1>
These questions came from a student in cs360 many many years ago -- since I imagine many 
students might share these questions, I am broadcasting the answers
to everyone.  

<hr>
<pre>&gt;1. Does the term uniprocessor mean that we have only one CPU, or is there 
&gt;   something else I should understand?
</pre>

That is correct -- one CPU (as opposed to a parallel processor that has
many CPUs)

<hr>
<pre>&gt;2. In the register &lt;--&gt; memory operation
&gt;                    st %r0 --&gt; [r1]
&gt;   the notes said "... treat the value of register r1 as a pointer to a memory
&gt;   location ...". Except for the pc, fp and the sp do we ever know where in 
&gt;   memory a register is pointing ?
</pre>

You can assume that the pc points to the code, and the fp/sp both point
to memory in the stack.  Even these assumptions can be violated in some
systems if you are doing complex stuff (I won't go into it).  Otherwise,
you cannot assume that a register is pointing to a specific memory
segment.  r1's pointer can point to the code, globals, heap or stack.

<hr>
<pre>&gt;3. Does each process assume that the address space is 0x80000000 ? If this is
&gt;   the number of bytes it looks huge to me. I got exactly 2048Mb. The hydras,
&gt;   for example, have only 96Mb of RAM.
&gt;   I got 2048 by doing
&gt;                      8*(16^7)/(1024^2).
&gt;   Am I making any wrong assumptions ? Things don't seem right.
</pre>

Yes, the process assumes that memory is an array of 2 GB.  However, 
it won't use all 2 GB.  In particular, the addresses between the stack
and heap are unused, and they compose the bulk of the address space.
Even though a processor may have much less than 2 GB in RAM, the system
is set up to look as though each process can access 2 GB.  This is 
called "virtual memory", and is something that you'll learn about in
CS361.  In a few weeks, we'll see how your interface to memory is
limited.  In particular, usually your code and globals segment is
smaller than a megabyte.  On my machine, the OS does not allow the 
stack to grow larger than 8M or so, (type "limit" and look at 
"stacksize") and it does not allow the heap to grow 
too much larger than 96MB.  If you don't believe me -- try it:<p>

The program <b><a href="http://web.eecs.utk.edu/~jplank/plank/classes/cs360/360/notes/Assembler1/test1.c">test1.c</a></b> tests the heap:

</p><p></p><center><table border="3" cellpadding="3"><tbody><tr><td><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char **argv)
{
  char *s;
  long sz;

  if (argc != 2 || sscanf(argv[1], "%ld", &amp;sz) == 0) {
    fprintf(stderr, "usage: test1 bytes\n");
    exit(1);
  }

  s = (char *) malloc(sz);

  if (s == NULL) { perror("malloc"); exit(1); }
  printf("malloc %ld worked\n", sz);
  return 0;
}
</pre></td></tr></tbody></table></center><p>

In 2018, you had to allocate quite a bit of memory to have the hydra's fail:

</p><pre>UNIX&gt; <font color="darkred"><b>gcc test1.c</b></font>
UNIX&gt; <font color="darkred"><b>a.out 6000000000</b></font>
malloc 6000000000 worked
UNIX&gt; <font color="darkred"><b>a.out 7000000000</b></font>
malloc: Cannot allocate memory
UNIX&gt; <font color="darkred"><b></b></font>
</pre>

My Raspberry Pi fails quicker:

<pre>pi@raspberrypi:~$ <font color="darkred"><b>gcc test1.c</b></font>
pi@raspberrypi:~$ <font color="darkred"><b>./a.out 400000000</b></font>
malloc 400000000 worked
pi@raspberrypi:~$ <font color="darkred"><b>./a.out 500000000</b></font>
malloc: Cannot allocate memory
pi@raspberrypi:~$ 
</pre>


This program (<b><a href="http://web.eecs.utk.edu/~jplank/plank/classes/cs360/360/notes/Assembler1/test2.c">test2.c</a></b>)
tests the stack:

<p></p><center><table border="3" cellpadding="3"><tbody><tr><td><pre>#include &lt;stdio.h&gt;

int main()
{
  char s[9000000];

  printf("s = 0x%x\n", s);
  printf("%d\n", *s);
  return 0;
}
</pre></td></tr></tbody></table></center><p>

As you can see below, our stacks are (as of 2018) limited to 8 MB, which seems like
plenty o fmemory to me.  So, when <b>test2.c</b> tries to allocate 9,000,000 bytes
on the stack, you get a seg fault:

</p><pre>UNIX&gt; <font color="darkred"><b>limit | grep stack</b></font>
stacksize    8192 kbytes
UNIX&gt; <font color="darkred"><b>gcc test2.c </b></font>
UNIX&gt; <font color="darkred"><b>./a.out</b></font>
Segmentation fault
UNIX&gt; <font color="darkred"><b></b></font>
</pre>

If we instead only allocate 8,000,000 bytes, it succeeds:

<pre>UNIX&gt; <font color="darkred"><b>sed 's/90/80/' test2.c &gt; test3.c</b></font>
UNIX&gt; <font color="darkred"><b>gcc test3.c</b></font>
UNIX&gt; <font color="darkred"><b>a.out</b></font>
s = 0xaf67d5d0
0
UNIX&gt; <font color="darkred"><b>rm test3.c a.out</b></font>
UNIX&gt; <font color="darkred"><b></b></font>
</pre>
</body></html>